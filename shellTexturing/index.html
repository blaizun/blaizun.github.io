<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shell Texturing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <div class="glass-overlay" id="glassOverlay"></div>
    <a href="../index.html" class="back-home-btn" id="backHomeBtn">
    <span class="arrow">
        <svg viewBox="0 0 24 24">
            <path d="M19 12H5M12 19l-7-7 7-7"/>
        </svg>
    </span>
    <span>Back Home</span>
    </a>
    <canvas id="canvas"></canvas>


    <script>

        //Back button
        const backHomeBtn = document.getElementById('backHomeBtn');
        const glassOverlay = document.getElementById('glassOverlay');

        backHomeBtn.addEventListener('mouseenter', () => {
            glassOverlay.classList.add('active');
        });

        backHomeBtn.addEventListener('mouseleave', () => {
            glassOverlay.classList.remove('active');
        });
        ///////////////

        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }

        let time = 0;
        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let cameraAngle = 0.5;
        let cameraRotation = 0.5;

        // GUI controls object
        const controls = {
            grassDensity: 116,
            grassHeight: 0.1,
            shellLayers: 10,
            bladeWidth: 0.15,
            baseGreen: [89, 191, 64],
            tipGreen: [198, 225, 30],
            groundBase: [77, 140, 64],
            groundDark: [57, 57, 35],
            windSpeed: 1.2,
            windStrength: 0.15,
            backgroundColor: [0,0,0]
        };

        // Create GUI
        const gui = new dat.GUI();
        
        const grassFolder = gui.addFolder('Grass Settings');
        grassFolder.add(controls, 'grassDensity', 10, 200).name('Density');
        grassFolder.add(controls, 'grassHeight', 0.1, 1).name('Height');
        grassFolder.add(controls, 'shellLayers', 2, 25).step(1).name('Shell Layers');
        grassFolder.add(controls, 'bladeWidth', 0.05, 0.5).name('Blade Width');
        grassFolder.addColor(controls, 'baseGreen').name('Base Color');
        grassFolder.addColor(controls, 'tipGreen').name('Tip Color');
        grassFolder.open();

        const windFolder = gui.addFolder('Wind');
        windFolder.add(controls, 'windSpeed', 0.5, 5.0).name('Speed');
        windFolder.add(controls, 'windStrength', 0.0, 0.5).name('Strength');
        windFolder.open();

        const groundFolder = gui.addFolder('Ground Colors');
        groundFolder.addColor(controls, 'groundBase').name('Base Color');
        groundFolder.addColor(controls, 'groundDark').name('Dark Color');
        groundFolder.open();

        const backgroundFolder = gui.addFolder('Background');
        backgroundFolder.addColor(controls, 'backgroundColor').name('Background Color');
        backgroundFolder.open();
        

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        canvas.addEventListener('mouseup', () => mouseDown = false);
        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                cameraRotation += deltaX * 0.005;
                cameraAngle = Math.max(0.1, Math.min(1.4, cameraAngle - deltaY * 0.003));
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        const vertexShader = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;
            attribute vec2 aTexCoord;
            
            uniform mat4 uProjection;
            uniform mat4 uView;
            uniform float uShellHeight;
            uniform float uTime;
            uniform float uWindSpeed;
            uniform float uWindStrength;
            uniform float uGrassHeight;
            
            varying vec2 vTexCoord;
            varying float vHeight;
            varying vec3 vWorldPos;
            varying vec3 vNormal;
            
            void main() {
                vec3 normal = normalize(aNormal);
                vec3 pos = aPosition;
                
                pos = pos + normal * uShellHeight;
                
                float heightRatio = uShellHeight / uGrassHeight;
                float wind = sin(uTime * uWindSpeed + aPosition.x * 2.0 + aPosition.z * 1.5) * uWindStrength;
                wind += sin(uTime * uWindSpeed * 1.5 + aPosition.x * 1.3 + aPosition.z * 2.1) * uWindStrength * 0.5;
                
                vec3 tangent = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));
                if (length(tangent) < 0.1) {
                    tangent = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));
                }
                vec3 bitangent = cross(normal, tangent);
                
                pos += tangent * wind * heightRatio;
                pos += bitangent * wind * heightRatio * 0.5;
                
                vWorldPos = pos;
                vTexCoord = aTexCoord;
                vHeight = uShellHeight;
                vNormal = normal;
                
                gl_Position = uProjection * uView * vec4(pos, 1.0);
            }
        `;

        const fragmentShader = `
            precision mediump float;
            
            uniform float uShellHeight;
            uniform float uMaxHeight;
            uniform float uTime;
            uniform float uGrassDensity;
            uniform float uBladeWidth;
            uniform vec3 uBaseGreen;
            uniform vec3 uTipGreen;
            
            varying vec2 vTexCoord;
            varying float vHeight;
            varying vec3 vWorldPos;
            varying vec3 vNormal;
            
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }
            
            void main() {
                float heightRatio = vHeight / uMaxHeight;
                
                vec2 grassCoord = vTexCoord * uGrassDensity;
                vec2 gridPos = floor(grassCoord);
                vec2 localPos = fract(grassCoord);
                
                float random = hash(gridPos);
                vec2 bladeCenter = vec2(0.5) + (vec2(hash(gridPos + vec2(1.0)), hash(gridPos + vec2(2.0))) - 0.5) * 0.6;
                
                float dist = length(localPos - bladeCenter);
                
                float bladeWidth = uBladeWidth * (1.0 - heightRatio * 0.7);
                float blade = smoothstep(bladeWidth + 0.1, bladeWidth, dist);
                
                float density = 1.0 - pow(heightRatio, 1.5);
                blade *= step(random, density);
                
                if (blade < 0.1) discard;
                
                vec3 darkGreen = vec3(0.2, 0.5, 0.15);
                
                vec3 grassColor = mix(uBaseGreen, uTipGreen, heightRatio);
                grassColor = mix(grassColor, darkGreen, random * 0.2);
                
                float lighting = dot(vNormal, normalize(vec3(0.5, 1.0, 0.3)));
                lighting = max(lighting, 0.3);
                lighting = floor(lighting * 3.0) / 3.0;
                grassColor *= lighting;
                
                float edgeDark = smoothstep(bladeWidth * 0.8, bladeWidth, dist);
                grassColor *= 0.7 + edgeDark * 0.3;
                
                float alpha = blade * (1.0 - heightRatio * 0.3);
                
                gl_FragColor = vec4(grassColor, alpha);
            }
        `;

        const groundVertexShader = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;
            attribute vec2 aTexCoord;
            
            uniform mat4 uProjection;
            uniform mat4 uView;
            
            varying vec2 vTexCoord;
            varying vec3 vNormal;
            
            void main() {
                vTexCoord = aTexCoord;
                vNormal = aNormal;
                gl_Position = uProjection * uView * vec4(aPosition, 1.0);
            }
        `;

        const groundFragmentShader = `
            precision mediump float;
            
            uniform vec3 uGroundBase;
            uniform vec3 uGroundDark;
            
            varying vec2 vTexCoord;
            varying vec3 vNormal;
            
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }
            
            void main() {
                vec2 noiseCoord = vTexCoord * 50.0;
                float noise = hash(floor(noiseCoord));
                
                vec3 groundColor = mix(uGroundBase, uGroundDark, noise * 0.3);
                
                float lighting = dot(normalize(vNormal), normalize(vec3(0.5, 1.0, 0.3)));
                lighting = max(lighting, 0.3);
                lighting = floor(lighting * 4.0) / 4.0;
                groundColor *= lighting;
                
                gl_FragColor = vec4(groundColor, 1.0);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(vs, fs) {
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const grassVS = createShader(gl.VERTEX_SHADER, vertexShader);
        const grassFS = createShader(gl.FRAGMENT_SHADER, fragmentShader);
        const grassProgram = createProgram(grassVS, grassFS);

        const groundVS = createShader(gl.VERTEX_SHADER, groundVertexShader);
        const groundFS = createShader(gl.FRAGMENT_SHADER, groundFragmentShader);
        const groundProgram = createProgram(groundVS, groundFS);

        // Create sphere geometry
        const sphereRadius = 2;
        const latSegments = 50;
        const lonSegments = 50;
        const vertices = [];
        const normals = [];
        const texCoords = [];
        const indices = [];

        for (let lat = 0; lat <= latSegments; lat++) {
            const theta = lat * Math.PI / latSegments;
            const sinTheta = Math.sin(theta);
            const cosTheta = Math.cos(theta);
            
            for (let lon = 0; lon <= lonSegments; lon++) {
                const phi = lon * 2 * Math.PI / lonSegments;
                const sinPhi = Math.sin(phi);
                const cosPhi = Math.cos(phi);
                
                const x = cosPhi * sinTheta;
                const y = cosTheta;
                const z = sinPhi * sinTheta;
                
                vertices.push(sphereRadius * x, sphereRadius * y, sphereRadius * z);
                normals.push(x, y, z);
                texCoords.push(lon / lonSegments, lat / latSegments);
            }
        }

        for (let lat = 0; lat < latSegments; lat++) {
            for (let lon = 0; lon < lonSegments; lon++) {
                const first = lat * (lonSegments + 1) + lon;
                const second = first + lonSegments + 1;
                
                indices.push(first, second, first + 1);
                indices.push(second, second + 1, first + 1);
            }
        }

        const sphereVertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        const sphereNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

        const sphereTexCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, sphereTexCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

        const sphereIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        function createProjectionMatrix(aspect) {
            const fov = Math.PI / 3.5;
            const near = 0.1;
            const far = 100;
            const f = 1.0 / Math.tan(fov / 2);
            
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) / (near - far), -1,
                0, 0, (2 * far * near) / (near - far), 0
            ];
        }

        function createViewMatrix(angle, rotation) {
            const distance = 6;
            const eye = [
                Math.sin(rotation) * distance * Math.cos(angle),
                Math.sin(angle) * distance,
                Math.cos(rotation) * distance * Math.cos(angle)
            ];
            const center = [0, 0, 0];
            const up = [0, 1, 0];
            
            const z = [
                eye[0] - center[0],
                eye[1] - center[1],
                eye[2] - center[2]
            ];
            const zLen = Math.sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);
            z[0] /= zLen; z[1] /= zLen; z[2] /= zLen;
            
            const x = [
                up[1] * z[2] - up[2] * z[1],
                up[2] * z[0] - up[0] * z[2],
                up[0] * z[1] - up[1] * z[0]
            ];
            const xLen = Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
            x[0] /= xLen; x[1] /= xLen; x[2] /= xLen;
            
            const y = [
                z[1] * x[2] - z[2] * x[1],
                z[2] * x[0] - z[0] * x[2],
                z[0] * x[1] - z[1] * x[0]
            ];
            
            return [
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -(x[0] * eye[0] + x[1] * eye[1] + x[2] * eye[2]),
                -(y[0] * eye[0] + y[1] * eye[1] + y[2] * eye[2]),
                -(z[0] * eye[0] + z[1] * eye[1] + z[2] * eye[2]),
                1
            ];
        }

        function render() {
            time += 0.016;

            gl.clearColor(controls.backgroundColor[0] / 255,controls.backgroundColor[1] / 255,controls.backgroundColor[2] / 255, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            
            const aspect = canvas.width / canvas.height;
            const projection = createProjectionMatrix(aspect);
            const view = createViewMatrix(cameraAngle, cameraRotation);

            // Render ground sphere
            gl.disable(gl.BLEND);
            gl.useProgram(groundProgram);
            
            const groundPos = gl.getAttribLocation(groundProgram, 'aPosition');
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexBuffer);
            gl.enableVertexAttribArray(groundPos);
            gl.vertexAttribPointer(groundPos, 3, gl.FLOAT, false, 0, 0);
            
            const groundNormal = gl.getAttribLocation(groundProgram, 'aNormal');
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalBuffer);
            gl.enableVertexAttribArray(groundNormal);
            gl.vertexAttribPointer(groundNormal, 3, gl.FLOAT, false, 0, 0);
            
            const groundTex = gl.getAttribLocation(groundProgram, 'aTexCoord');
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereTexCoordBuffer);
            gl.enableVertexAttribArray(groundTex);
            gl.vertexAttribPointer(groundTex, 2, gl.FLOAT, false, 0, 0);
            
            gl.uniformMatrix4fv(gl.getUniformLocation(groundProgram, 'uProjection'), false, projection);
            gl.uniformMatrix4fv(gl.getUniformLocation(groundProgram, 'uView'), false, view);
            gl.uniform3f(gl.getUniformLocation(groundProgram, 'uGroundBase'), 
                controls.groundBase[0] / 255, controls.groundBase[1] / 255, controls.groundBase[2] / 255);
            gl.uniform3f(gl.getUniformLocation(groundProgram, 'uGroundDark'), 
                controls.groundDark[0] / 255, controls.groundDark[1] / 255, controls.groundDark[2] / 255);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexBuffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

            // Render grass shells
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.useProgram(grassProgram);
            
            const aPosition = gl.getAttribLocation(grassProgram, 'aPosition');
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexBuffer);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
            
            const aNormal = gl.getAttribLocation(grassProgram, 'aNormal');
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalBuffer);
            gl.enableVertexAttribArray(aNormal);
            gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);
            
            const aTexCoord = gl.getAttribLocation(grassProgram, 'aTexCoord');
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereTexCoordBuffer);
            gl.enableVertexAttribArray(aTexCoord);
            gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 0, 0);
            
            gl.uniformMatrix4fv(gl.getUniformLocation(grassProgram, 'uProjection'), false, projection);
            gl.uniformMatrix4fv(gl.getUniformLocation(grassProgram, 'uView'), false, view);
            gl.uniform1f(gl.getUniformLocation(grassProgram, 'uTime'), time);
            gl.uniform1f(gl.getUniformLocation(grassProgram, 'uMaxHeight'), controls.grassHeight);
            gl.uniform1f(gl.getUniformLocation(grassProgram, 'uGrassDensity'), controls.grassDensity);
            gl.uniform1f(gl.getUniformLocation(grassProgram, 'uBladeWidth'), controls.bladeWidth);
            gl.uniform1f(gl.getUniformLocation(grassProgram, 'uWindSpeed'), controls.windSpeed);
            gl.uniform1f(gl.getUniformLocation(grassProgram, 'uWindStrength'), controls.windStrength);
            gl.uniform1f(gl.getUniformLocation(grassProgram, 'uGrassHeight'), controls.grassHeight);
            gl.uniform3f(gl.getUniformLocation(grassProgram, 'uBaseGreen'), 
                controls.baseGreen[0] / 255, controls.baseGreen[1] / 255, controls.baseGreen[2] / 255);
            gl.uniform3f(gl.getUniformLocation(grassProgram, 'uTipGreen'), 
                controls.tipGreen[0] / 255, controls.tipGreen[1] / 255, controls.tipGreen[2] / 255);
            
            // Draw each shell layer
            for (let i = 0; i <= controls.shellLayers; i++) {
                const height = (i / controls.shellLayers) * controls.grassHeight;
                gl.uniform1f(gl.getUniformLocation(grassProgram, 'uShellHeight'), height);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexBuffer);
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            }
            
            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>